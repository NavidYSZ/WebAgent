Hier ist die **abschlieÃŸende Architektur**, die gleichzeitig **(a) zuverlÃ¤ssig funktioniert** und **(b) wirklich den Intent erfÃ¼llt**: AI-gestÃ¼tzte Entwicklung wird *planbar, delegierbar, Ã¼berprÃ¼fbar* â€“ auch fÃ¼r **mittlere bis mittelgroÃŸe Projekte**.

---

## Zielbild in einem Satz

Du baust ein System, in dem **jede Arbeitseinheit** als **WorkOrder + Contracts + Tests** beschrieben ist, sodass **Worker ohne Gesamtkontext** trotzdem korrekt liefern â€“ und der Orchestrator nur noch **plant, zerlegt, prÃ¼ft, konsolidiert**.

---

## 1) Die 5 Bausteine (minimal, aber vollstÃ¤ndig)

### A) Source of Truth im Repo (fÃ¼r Kontext-StabilitÃ¤t)

**Alles Wichtige liegt als Dateien im Repo**, nicht â€œnur im Chatâ€:

* `docs/module-registry.yaml` (Index aller Module)
* `docs/modules/<module>.md` (Modul-Spezifikation: Input/Output/Errors/DoD)
* `docs/contracts/*` (OpenAPI/JSON-Schema/Event-Schemas)
* `docs/decisions/ADR-*.md` (bewusste Entscheidungen)

ğŸ‘‰ Ergebnis: Worker mÃ¼ssen nicht â€ratenâ€œ, wie etwas gedacht ist.

---

### B) WorkOrders als â€Context Packsâ€œ (delegierbar)

Jeder Task wird **nicht** als â€œmach mal Xâ€ beschrieben, sondern als **ausfÃ¼hrbares Paket**:

* Ziel (1 Satz)
* Scope/Constraints (was darf nicht verÃ¤ndert werden)
* Links zu Modulspec/Contracts
* **Files-Allowlist** + **Commands-Allowlist**
* **Acceptance Criteria** (objektiv prÃ¼fbar: Tests/Schema-Validation)
* Deliverables: Patch + Testlog + Digest

ğŸ‘‰ Ergebnis: Du kannst Aufgaben beliebig an Worker geben, ohne dass sie â€den ganzen Filmâ€œ kennen mÃ¼ssen.

---

### C) Execution Layer (OpenHands / Codex / eigener Runner â€“ egal)

Die AusfÃ¼hrung passiert in einer isolierten Workspace-Umgebung:

* Repo checkout (Branch pro Run)
* Ã„nderungen **diff-first**
* Tests laufen lassen
* Artefakte speichern

ğŸ‘‰ Der Tool-Wechsel (OpenHands Web, CLI, Codex, eigener Orchestrator) Ã¤ndert **nicht** deine Prozesslogik, nur die â€œExecution Engineâ€.

---

### D) Artifact Store + Metadaten (einfach & update-sicher)

**Hybrid Speicherung (empfohlen):**

* **SQLite**: Projekte, Runs, Status, Links, Indizes (super simpel, eine Datei)
* **Filesystem**: groÃŸe Artefakte (diff/log/digest/adr), weil diffbar & agent-freundlich

Ordneridee:

* `data/app.sqlite`
* `data/artifacts/<run>/<artifact>.(diff|log|json|md)`

ğŸ‘‰ Ergebnis: Keine MariaDB/Plesk-HÃ¶lle, keine â€œbei Update alles lÃ¶schenâ€, trotzdem querybar.

---

### E) Gatekeeping (macht es verlÃ¤sslich)

Du brauchst 3 harte Gates, damit â€œAI macht Mistâ€ nicht eskaliert:

1. **Contracts Gate:** Schema/OpenAPI/Event-Contract muss validieren
2. **Tests Gate:** unit/contract/integration (klein aber zwingend)
3. **Review Gate:** Orchestrator akzeptiert nur, wenn Digest+Evidence plausibel sind

ğŸ‘‰ Ergebnis: QualitÃ¤t steigt, Debug-Zeit sinkt.

---

## 2) Rollenmodell (damit mittlere Projekte wirklich skalieren)

### Minimal: **2 Ebenen** (reicht in 90% der FÃ¤lle)

* **Orchestrator (du oder â€Brainâ€œ)**

  * zerlegt Arbeit in WorkOrders
  * priorisiert
  * prÃ¼ft Artefakte & integriert
  * schreibt/aktualisiert ADRs/Registry
* **Worker(s)**

  * implementieren genau *eine* WorkOrder
  * liefern Patch + Tests + Digest

Das ist der Sweet Spot: maximal effizient, minimaler Koordinations-Overhead.

### Optional: â€œHierarchieâ€ nur als Pattern (nicht als Dauerzustand)

Wenn ein Task groÃŸ ist, macht der Orchestrator:

* 1 Epic-WorkOrder â†’ 3â€“8 kleine WorkOrders (pro Modul/Feature Slice)
* Worker arbeiten parallel
* Orchestrator konsolidiert

Mehr als 2 Ebenen lohnt sich meist erst, wenn du wirklich **dauerhaft** parallelisiert + automatisiert (CI/PR-Flows, 20+ Runs/Woche).

---

## 3) Der Entwicklungsfluss (so wirdâ€™s effizient)

1. **Planung**

   * Update/Erstellung: `module-registry`, `module spec`, `contracts`
2. **WorkOrder erzeugen**

   * klein, testbar, mit allowlists + acceptance criteria
3. **Run**

   * Worker Ã¤ndert Code, fÃ¼hrt Tests aus, erzeugt Artefakte
4. **Evidence Review**

   * Orchestrator checkt: Patch + Testlog + Contract-Validation + Digest
5. **Merge**

   * Branch/PR rein
6. **Wissens-Update**

   * ADR/Specs aktualisieren, falls Interface/Entscheidung geÃ¤ndert wurde

ğŸ‘‰ Dieser Loop ist das, was mittlere Projekte â€schnell und sauberâ€œ macht: Nicht mehr â€groÃŸe Chat-Sessionsâ€œ, sondern **kleine beweisbare Schritte**.

---

## 4) Warum das den Intent erfÃ¼llt (und nicht nur â€œDokumentationâ€ ist)

### Worker ohne Gesamtkontext funktionieren, weil:

* sie **nur** ein Modul/Slice bearbeiten
* alle Inputs/Outputs **contracted** sind
* Erfolg Ã¼ber Tests/Schema objektiv messbar ist

### Mittlere Projekte funktionieren, weil:

* Du nicht in â€œMonolith-Promptsâ€ erstickst
* Jede Ã„nderung an Interfaces/Events/DB bewusst versioniert wird (ADR/Contracts)
* Du parallelisieren kannst, ohne Chaos (WorkOrders + Gates)

### AI wird wirklich effizienter, weil:

* Kontext nicht dauernd neu â€œerzÃ¤hltâ€ werden muss (Specs + Registry)
* Fehler frÃ¼h sichtbar sind (Contracts/Tests statt spÃ¤t im Review)
* du Wiederholungen automatisierst (WorkOrder-Generator + Standard-DoD)

---

## 5) Minimaler Implementations-Scope (damit es schnell funktionsfÃ¤hig ist)

Wenn du es maximal pragmatisch willst, starte so:

* **Files:** `docs/`, `work_orders/`, `contracts/`, `decisions/`
* **Storage:** `data/app.sqlite` + `data/artifacts/`
* **Gates:** 1 Contract-Test + 1 Integration-Test pro Modul (klein halten)
* **Execution:** OpenHands/Codex wie gewohnt, aber **Output immer in Artefakte**

Damit ist es **sofort funktionsfÃ¤hig** und du kannst spÃ¤ter den Orchestrator â€œautomatisierenâ€, ohne den Prozess zu Ã¤ndern.

---
